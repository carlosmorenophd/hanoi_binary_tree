{"ast":null,"code":"module.exports = function () {\n  // Flag bad practises\n  'use strict';\n\n  // ------------------------------------\n  // Basic Setup\n  // ------------------------------------\n\n  /**\n   * @class Traverser\n   * @constructor\n   * @classdesc Represents a traverser which searches/traverses the tree in BFS and DFS fashion.\n   * @param tree - {@link Tree} that has to be traversed or search.\n   */\n  function Traverser(tree) {\n    if (!tree) throw new Error('Could not find a tree that is to be traversed');\n\n    /**\n     * Represents the {@link Tree} which has to be traversed.\n     *\n     * @property _tree\n     * @type {object}\n     * @default \"null\"\n     */\n    this._tree = tree;\n  }\n\n  // ------------------------------------\n  // Methods\n  // ------------------------------------\n\n  /**\n   * Searches a tree in DFS fashion. Requires a search criteria to be provided.\n   *\n   * @method searchDFS\n   * @memberof Traverser\n   * @instance\n   * @param {function} criteria - MUST BE a callback function that specifies the search criteria.\n   * Criteria callback here receives {@link TreeNode#_data} in parameter and MUST return boolean\n   * indicating whether that data satisfies your criteria.\n   * @return {object} - first {@link TreeNode} in tree that matches the given criteria.\n   * @example\n   * // Search DFS\n   * var node = tree.traverser().searchDFS(function(data){\n   *  return data.key === '#greenapple';\n   * });\n   */\n  Traverser.prototype.searchDFS = function (criteria) {\n    // Hold the node when found\n    var foundNode = null;\n\n    // Find node recursively\n    (function recur(node) {\n      if (node.matchCriteria(criteria)) {\n        foundNode = node;\n        return foundNode;\n      } else {\n        node._childNodes.some(recur);\n      }\n    })(this._tree._rootNode);\n    return foundNode;\n  };\n\n  /**\n   * Searches a tree in BFS fashion. Requires a search criteria to be provided.\n   *\n   * @method searchBFS\n   * @memberof Traverser\n   * @instance\n   * @param {function} criteria - MUST BE a callback function that specifies the search criteria.\n   * Criteria callback here receives {@link TreeNode#_data} in parameter and MUST return boolean\n   * indicating whether that data satisfies your criteria.\n   * @return {object} - first {@link TreeNode} in tree that matches the given criteria.\n   * @example\n   * // Search BFS\n   * var node = tree.traverser().searchBFS(function(data){\n   *  return data.key === '#greenapple';\n   * });\n   */\n  Traverser.prototype.searchBFS = function (criteria) {\n    // Hold the node when found\n    var foundNode = null;\n\n    // Find nodes recursively\n    (function expand(queue) {\n      while (queue.length) {\n        var current = queue.splice(0, 1)[0];\n        if (current.matchCriteria(criteria)) {\n          foundNode = current;\n          return;\n        }\n        current._childNodes.forEach(function (_child) {\n          queue.push(_child);\n        });\n      }\n    })([this._tree._rootNode]);\n    return foundNode;\n  };\n\n  /**\n   * Traverses an entire tree in DFS fashion.\n   *\n   * @method traverseDFS\n   * @memberof Traverser\n   * @instance\n   * @param {function} callback - Gets triggered when @{link TreeNode} is explored. Explored node is passed as parameter to callback.\n   * @example\n   * // Traverse DFS\n   * tree.traverser().traverseDFS(function(node){\n   *  console.log(node.data);\n   * });\n   */\n  Traverser.prototype.traverseDFS = function (callback) {\n    (function recur(node) {\n      callback(node);\n      node._childNodes.forEach(recur);\n    })(this._tree._rootNode);\n  };\n\n  /**\n   * Traverses an entire tree in BFS fashion.\n   *\n   * @method traverseBFS\n   * @memberof Traverser\n   * @instance\n   * @param {function} callback - Gets triggered when node is explored. Explored node is passed as parameter to callback.\n   * @example\n   * // Traverse BFS\n   * tree.traverser().traverseBFS(function(node){\n   *  console.log(node.data);\n   * });\n   */\n  Traverser.prototype.traverseBFS = function (callback) {\n    (function expand(queue) {\n      while (queue.length) {\n        var current = queue.splice(0, 1)[0];\n        callback(current);\n        current._childNodes.forEach(function (_child) {\n          queue.push(_child);\n        });\n      }\n    })([this._tree._rootNode]);\n  };\n\n  // ------------------------------------\n  // Export\n  // ------------------------------------\n\n  return Traverser;\n}();","map":{"version":3,"names":["module","exports","Traverser","tree","Error","_tree","prototype","searchDFS","criteria","foundNode","recur","node","matchCriteria","_childNodes","some","_rootNode","searchBFS","expand","queue","length","current","splice","forEach","_child","push","traverseDFS","callback","traverseBFS"],"sources":["/home/ubuntu/repo/architec_of_computer_1/hanoi-react/node_modules/data-tree/src/traverser.js"],"sourcesContent":["\nmodule.exports = (function(){\n\n  // Flag bad practises\n  'use strict';\n\n  // ------------------------------------\n  // Basic Setup\n  // ------------------------------------\n\n  /**\n   * @class Traverser\n   * @constructor\n   * @classdesc Represents a traverser which searches/traverses the tree in BFS and DFS fashion.\n   * @param tree - {@link Tree} that has to be traversed or search.\n   */\n  function Traverser(tree){\n\n    if(!tree)\n    throw new Error('Could not find a tree that is to be traversed');\n\n    /**\n     * Represents the {@link Tree} which has to be traversed.\n     *\n     * @property _tree\n     * @type {object}\n     * @default \"null\"\n     */\n    this._tree = tree;\n\n  }\n\n  // ------------------------------------\n  // Methods\n  // ------------------------------------\n\n  /**\n   * Searches a tree in DFS fashion. Requires a search criteria to be provided.\n   *\n   * @method searchDFS\n   * @memberof Traverser\n   * @instance\n   * @param {function} criteria - MUST BE a callback function that specifies the search criteria.\n   * Criteria callback here receives {@link TreeNode#_data} in parameter and MUST return boolean\n   * indicating whether that data satisfies your criteria.\n   * @return {object} - first {@link TreeNode} in tree that matches the given criteria.\n   * @example\n   * // Search DFS\n   * var node = tree.traverser().searchDFS(function(data){\n   *  return data.key === '#greenapple';\n   * });\n   */\n  Traverser.prototype.searchDFS = function(criteria){\n\n    // Hold the node when found\n    var foundNode = null;\n\n    // Find node recursively\n    (function recur(node){\n      if(node.matchCriteria(criteria)){\n        foundNode = node;\n        return foundNode;\n      } else {\n        node._childNodes.some(recur);\n      }\n    }(this._tree._rootNode));\n\n    return foundNode;\n  };\n\n  /**\n   * Searches a tree in BFS fashion. Requires a search criteria to be provided.\n   *\n   * @method searchBFS\n   * @memberof Traverser\n   * @instance\n   * @param {function} criteria - MUST BE a callback function that specifies the search criteria.\n   * Criteria callback here receives {@link TreeNode#_data} in parameter and MUST return boolean\n   * indicating whether that data satisfies your criteria.\n   * @return {object} - first {@link TreeNode} in tree that matches the given criteria.\n   * @example\n   * // Search BFS\n   * var node = tree.traverser().searchBFS(function(data){\n   *  return data.key === '#greenapple';\n   * });\n   */\n  Traverser.prototype.searchBFS = function(criteria){\n\n    // Hold the node when found\n    var foundNode = null;\n\n    // Find nodes recursively\n    (function expand(queue){\n      while(queue.length){\n        var current = queue.splice(0, 1)[0];\n        if(current.matchCriteria(criteria)){\n          foundNode = current;\n          return;\n        }\n        current._childNodes.forEach(function(_child){\n          queue.push(_child);\n        });\n      }\n    }([this._tree._rootNode]));\n\n\n    return foundNode;\n\n  };\n\n  /**\n   * Traverses an entire tree in DFS fashion.\n   *\n   * @method traverseDFS\n   * @memberof Traverser\n   * @instance\n   * @param {function} callback - Gets triggered when @{link TreeNode} is explored. Explored node is passed as parameter to callback.\n   * @example\n   * // Traverse DFS\n   * tree.traverser().traverseDFS(function(node){\n   *  console.log(node.data);\n   * });\n   */\n  Traverser.prototype.traverseDFS = function(callback){\n    (function recur(node){\n      callback(node);\n      node._childNodes.forEach(recur);\n    }(this._tree._rootNode));\n  };\n\n  /**\n   * Traverses an entire tree in BFS fashion.\n   *\n   * @method traverseBFS\n   * @memberof Traverser\n   * @instance\n   * @param {function} callback - Gets triggered when node is explored. Explored node is passed as parameter to callback.\n   * @example\n   * // Traverse BFS\n   * tree.traverser().traverseBFS(function(node){\n   *  console.log(node.data);\n   * });\n   */\n  Traverser.prototype.traverseBFS = function(callback){\n    (function expand(queue){\n      while(queue.length){\n        var current = queue.splice(0, 1)[0];\n        callback(current);\n        current._childNodes.forEach(function(_child){\n          queue.push(_child);\n        });\n      }\n    }([this._tree._rootNode]));\n  };\n\n  // ------------------------------------\n  // Export\n  // ------------------------------------\n\n  return Traverser;\n\n}());\n"],"mappings":"AACAA,MAAM,CAACC,OAAO,GAAI,YAAU;EAE1B;EACA,YAAY;;EAEZ;EACA;EACA;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,SAASC,SAASA,CAACC,IAAI,EAAC;IAEtB,IAAG,CAACA,IAAI,EACR,MAAM,IAAIC,KAAK,CAAC,+CAA+C,CAAC;;IAEhE;AACJ;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,KAAK,GAAGF,IAAI;EAEnB;;EAEA;EACA;EACA;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACED,SAAS,CAACI,SAAS,CAACC,SAAS,GAAG,UAASC,QAAQ,EAAC;IAEhD;IACA,IAAIC,SAAS,GAAG,IAAI;;IAEpB;IACC,UAASC,KAAKA,CAACC,IAAI,EAAC;MACnB,IAAGA,IAAI,CAACC,aAAa,CAACJ,QAAQ,CAAC,EAAC;QAC9BC,SAAS,GAAGE,IAAI;QAChB,OAAOF,SAAS;MAClB,CAAC,MAAM;QACLE,IAAI,CAACE,WAAW,CAACC,IAAI,CAACJ,KAAK,CAAC;MAC9B;IACF,CAAC,EAAC,IAAI,CAACL,KAAK,CAACU,SAAS,CAAC;IAEvB,OAAON,SAAS;EAClB,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEP,SAAS,CAACI,SAAS,CAACU,SAAS,GAAG,UAASR,QAAQ,EAAC;IAEhD;IACA,IAAIC,SAAS,GAAG,IAAI;;IAEpB;IACC,UAASQ,MAAMA,CAACC,KAAK,EAAC;MACrB,OAAMA,KAAK,CAACC,MAAM,EAAC;QACjB,IAAIC,OAAO,GAAGF,KAAK,CAACG,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QACnC,IAAGD,OAAO,CAACR,aAAa,CAACJ,QAAQ,CAAC,EAAC;UACjCC,SAAS,GAAGW,OAAO;UACnB;QACF;QACAA,OAAO,CAACP,WAAW,CAACS,OAAO,CAAC,UAASC,MAAM,EAAC;UAC1CL,KAAK,CAACM,IAAI,CAACD,MAAM,CAAC;QACpB,CAAC,CAAC;MACJ;IACF,CAAC,EAAC,CAAC,IAAI,CAAClB,KAAK,CAACU,SAAS,CAAC,CAAC;IAGzB,OAAON,SAAS;EAElB,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEP,SAAS,CAACI,SAAS,CAACmB,WAAW,GAAG,UAASC,QAAQ,EAAC;IACjD,UAAShB,KAAKA,CAACC,IAAI,EAAC;MACnBe,QAAQ,CAACf,IAAI,CAAC;MACdA,IAAI,CAACE,WAAW,CAACS,OAAO,CAACZ,KAAK,CAAC;IACjC,CAAC,EAAC,IAAI,CAACL,KAAK,CAACU,SAAS,CAAC;EACzB,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEb,SAAS,CAACI,SAAS,CAACqB,WAAW,GAAG,UAASD,QAAQ,EAAC;IACjD,UAAST,MAAMA,CAACC,KAAK,EAAC;MACrB,OAAMA,KAAK,CAACC,MAAM,EAAC;QACjB,IAAIC,OAAO,GAAGF,KAAK,CAACG,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QACnCK,QAAQ,CAACN,OAAO,CAAC;QACjBA,OAAO,CAACP,WAAW,CAACS,OAAO,CAAC,UAASC,MAAM,EAAC;UAC1CL,KAAK,CAACM,IAAI,CAACD,MAAM,CAAC;QACpB,CAAC,CAAC;MACJ;IACF,CAAC,EAAC,CAAC,IAAI,CAAClB,KAAK,CAACU,SAAS,CAAC,CAAC;EAC3B,CAAC;;EAED;EACA;EACA;;EAEA,OAAOb,SAAS;AAElB,CAAC,EAAG"},"metadata":{},"sourceType":"script","externalDependencies":[]}