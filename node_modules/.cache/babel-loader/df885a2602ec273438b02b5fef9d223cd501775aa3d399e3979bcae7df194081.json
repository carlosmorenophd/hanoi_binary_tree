{"ast":null,"code":"import React from 'react';\nimport { tree as d3tree, hierarchy } from 'd3-hierarchy';\nimport { select } from 'd3-selection';\nimport { zoom as d3zoom, zoomIdentity } from 'd3-zoom';\nimport { dequal as deepEqual } from 'dequal/lite';\nimport clone from 'clone';\nimport { v4 as uuidv4 } from 'uuid';\nimport TransitionGroupWrapper from './TransitionGroupWrapper.js';\nimport Node from '../Node/index.js';\nimport Link from '../Link/index.js';\nimport globalCss from '../globalCss.js';\nclass Tree extends React.Component {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      dataRef: this.props.data,\n      data: Tree.assignInternalProperties(clone(this.props.data)),\n      d3: Tree.calculateD3Geometry(this.props),\n      isTransitioning: false,\n      isInitialRenderForDataset: true\n    };\n    this.internalState = {\n      targetNode: null,\n      isTransitioning: false\n    };\n    this.svgInstanceRef = `rd3t-svg-${uuidv4()}`;\n    this.gInstanceRef = `rd3t-g-${uuidv4()}`;\n    /**\n     * Finds the node matching `nodeId` and\n     * expands/collapses it, depending on the current state of\n     * its internal `collapsed` property.\n     * `setState` callback receives targetNode and handles\n     * `props.onClick` if defined.\n     */\n    this.handleNodeToggle = nodeId => {\n      const data = clone(this.state.data);\n      const matches = this.findNodesById(nodeId, data, []);\n      const targetNodeDatum = matches[0];\n      if (this.props.collapsible && !this.state.isTransitioning) {\n        if (targetNodeDatum.__rd3t.collapsed) {\n          Tree.expandNode(targetNodeDatum);\n          this.props.shouldCollapseNeighborNodes && this.collapseNeighborNodes(targetNodeDatum, data);\n        } else {\n          Tree.collapseNode(targetNodeDatum);\n        }\n        if (this.props.enableLegacyTransitions) {\n          // Lock node toggling while transition takes place.\n          this.setState({\n            data,\n            isTransitioning: true\n          });\n          // Await transitionDuration + 10 ms before unlocking node toggling again.\n          setTimeout(() => this.setState({\n            isTransitioning: false\n          }), this.props.transitionDuration + 10);\n        } else {\n          this.setState({\n            data\n          });\n        }\n        this.internalState.targetNode = targetNodeDatum;\n      }\n    };\n    /**\n     * Handles the user-defined `onNodeClick` function.\n     */\n    this.handleOnNodeClickCb = (hierarchyPointNode, evt) => {\n      const {\n        onNodeClick\n      } = this.props;\n      if (onNodeClick && typeof onNodeClick === 'function') {\n        // Persist the SyntheticEvent for downstream handling by users.\n        evt.persist();\n        onNodeClick(clone(hierarchyPointNode), evt);\n      }\n    };\n    /**\n     * Handles the user-defined `onLinkClick` function.\n     */\n    this.handleOnLinkClickCb = (linkSource, linkTarget, evt) => {\n      const {\n        onLinkClick\n      } = this.props;\n      if (onLinkClick && typeof onLinkClick === 'function') {\n        // Persist the SyntheticEvent for downstream handling by users.\n        evt.persist();\n        onLinkClick(clone(linkSource), clone(linkTarget), evt);\n      }\n    };\n    /**\n     * Handles the user-defined `onNodeMouseOver` function.\n     */\n    this.handleOnNodeMouseOverCb = (hierarchyPointNode, evt) => {\n      const {\n        onNodeMouseOver\n      } = this.props;\n      if (onNodeMouseOver && typeof onNodeMouseOver === 'function') {\n        // Persist the SyntheticEvent for downstream handling by users.\n        evt.persist();\n        onNodeMouseOver(clone(hierarchyPointNode), evt);\n      }\n    };\n    /**\n     * Handles the user-defined `onLinkMouseOver` function.\n     */\n    this.handleOnLinkMouseOverCb = (linkSource, linkTarget, evt) => {\n      const {\n        onLinkMouseOver\n      } = this.props;\n      if (onLinkMouseOver && typeof onLinkMouseOver === 'function') {\n        // Persist the SyntheticEvent for downstream handling by users.\n        evt.persist();\n        onLinkMouseOver(clone(linkSource), clone(linkTarget), evt);\n      }\n    };\n    /**\n     * Handles the user-defined `onNodeMouseOut` function.\n     */\n    this.handleOnNodeMouseOutCb = (hierarchyPointNode, evt) => {\n      const {\n        onNodeMouseOut\n      } = this.props;\n      if (onNodeMouseOut && typeof onNodeMouseOut === 'function') {\n        // Persist the SyntheticEvent for downstream handling by users.\n        evt.persist();\n        onNodeMouseOut(clone(hierarchyPointNode), evt);\n      }\n    };\n    /**\n     * Handles the user-defined `onLinkMouseOut` function.\n     */\n    this.handleOnLinkMouseOutCb = (linkSource, linkTarget, evt) => {\n      const {\n        onLinkMouseOut\n      } = this.props;\n      if (onLinkMouseOut && typeof onLinkMouseOut === 'function') {\n        // Persist the SyntheticEvent for downstream handling by users.\n        evt.persist();\n        onLinkMouseOut(clone(linkSource), clone(linkTarget), evt);\n      }\n    };\n    /**\n     * Takes a hierarchy point node and centers the node on the screen\n     * if the dimensions parameter is passed to `Tree`.\n     *\n     * This code is adapted from Rob Schmuecker's centerNode method.\n     * Link: http://bl.ocks.org/robschmuecker/7880033\n     */\n    this.centerNode = hierarchyPointNode => {\n      const {\n        dimensions,\n        orientation,\n        zoom,\n        centeringTransitionDuration\n      } = this.props;\n      if (dimensions) {\n        const g = select(`.${this.gInstanceRef}`);\n        const svg = select(`.${this.svgInstanceRef}`);\n        const scale = this.state.d3.scale;\n        let x;\n        let y;\n        // if the orientation is horizontal, calculate the variables inverted (x->y, y->x)\n        if (orientation === 'horizontal') {\n          y = -hierarchyPointNode.x * scale + dimensions.height / 2;\n          x = -hierarchyPointNode.y * scale + dimensions.width / 2;\n        } else {\n          // else, calculate the variables normally (x->x, y->y)\n          x = -hierarchyPointNode.x * scale + dimensions.width / 2;\n          y = -hierarchyPointNode.y * scale + dimensions.height / 2;\n        }\n        //@ts-ignore\n        g.transition().duration(centeringTransitionDuration).attr('transform', 'translate(' + x + ',' + y + ')scale(' + scale + ')');\n        // Sets the viewport to the new center so that it does not jump back to original\n        // coordinates when dragged/zoomed\n        //@ts-ignore\n        svg.call(d3zoom().transform, zoomIdentity.translate(x, y).scale(zoom));\n      }\n    };\n    /**\n     * Determines which additional `className` prop should be passed to the node & returns it.\n     */\n    this.getNodeClassName = (parent, nodeDatum) => {\n      const {\n        rootNodeClassName,\n        branchNodeClassName,\n        leafNodeClassName\n      } = this.props;\n      const hasParent = parent !== null && parent !== undefined;\n      if (hasParent) {\n        return nodeDatum.children ? branchNodeClassName : leafNodeClassName;\n      } else {\n        return rootNodeClassName;\n      }\n    };\n  }\n  static getDerivedStateFromProps(nextProps, prevState) {\n    let derivedState = null;\n    // Clone new data & assign internal properties if `data` object reference changed.\n    if (nextProps.data !== prevState.dataRef) {\n      derivedState = {\n        dataRef: nextProps.data,\n        data: Tree.assignInternalProperties(clone(nextProps.data)),\n        isInitialRenderForDataset: true\n      };\n    }\n    const d3 = Tree.calculateD3Geometry(nextProps);\n    if (!deepEqual(d3, prevState.d3)) {\n      derivedState = derivedState || {};\n      derivedState.d3 = d3;\n    }\n    return derivedState;\n  }\n  componentDidMount() {\n    this.bindZoomListener(this.props);\n    this.setState({\n      isInitialRenderForDataset: false\n    });\n  }\n  componentDidUpdate(prevProps) {\n    if (this.props.data !== prevProps.data) {\n      // If last `render` was due to change in dataset -> mark the initial render as done.\n      this.setState({\n        isInitialRenderForDataset: false\n      });\n    }\n    if (!deepEqual(this.props.translate, prevProps.translate) || !deepEqual(this.props.scaleExtent, prevProps.scaleExtent) || this.props.zoomable !== prevProps.zoomable || this.props.draggable !== prevProps.draggable || this.props.zoom !== prevProps.zoom || this.props.enableLegacyTransitions !== prevProps.enableLegacyTransitions) {\n      // If zoom-specific props change -> rebind listener with new values.\n      // Or: rebind zoom listeners to new DOM nodes in case legacy transitions were enabled/disabled.\n      this.bindZoomListener(this.props);\n    }\n    if (typeof this.props.onUpdate === 'function') {\n      this.props.onUpdate({\n        node: this.internalState.targetNode ? clone(this.internalState.targetNode) : null,\n        zoom: this.state.d3.scale,\n        translate: this.state.d3.translate\n      });\n    }\n    // Reset the last target node after we've flushed it to `onUpdate`.\n    this.internalState.targetNode = null;\n  }\n  /**\n   * Collapses all tree nodes with a `depth` larger than `initialDepth`.\n   *\n   * @param {array} nodeSet Array of nodes generated by `generateTree`\n   * @param {number} initialDepth Maximum initial depth the tree should render\n   */\n  setInitialTreeDepth(nodeSet, initialDepth) {\n    nodeSet.forEach(n => {\n      n.data.__rd3t.collapsed = n.depth >= initialDepth;\n    });\n  }\n  /**\n   * bindZoomListener - If `props.zoomable`, binds a listener for\n   * \"zoom\" events to the SVG and sets scaleExtent to min/max\n   * specified in `props.scaleExtent`.\n   */\n  bindZoomListener(props) {\n    const {\n      zoomable,\n      scaleExtent,\n      translate,\n      zoom,\n      onUpdate,\n      hasInteractiveNodes\n    } = props;\n    const svg = select(`.${this.svgInstanceRef}`);\n    const g = select(`.${this.gInstanceRef}`);\n    // Sets initial offset, so that first pan and zoom does not jump back to default [0,0] coords.\n    // @ts-ignore\n    svg.call(d3zoom().transform, zoomIdentity.translate(translate.x, translate.y).scale(zoom));\n    svg.call(d3zoom().scaleExtent(zoomable ? [scaleExtent.min, scaleExtent.max] : [zoom, zoom])\n    // TODO: break this out into a separate zoom handler fn, rather than inlining it.\n    .filter(event => {\n      if (hasInteractiveNodes) {\n        return event.target.classList.contains(this.svgInstanceRef) || event.target.classList.contains(this.gInstanceRef) || event.shiftKey;\n      }\n      return true;\n    }).on('zoom', event => {\n      if (!this.props.draggable && event.sourceEvent.type === 'mousemove') {\n        return;\n      }\n      g.attr('transform', event.transform);\n      if (typeof onUpdate === 'function') {\n        // This callback is magically called not only on \"zoom\", but on \"drag\", as well,\n        // even though event.type == \"zoom\".\n        // Taking advantage of this and not writing a \"drag\" handler.\n        onUpdate({\n          node: null,\n          zoom: event.transform.k,\n          translate: {\n            x: event.transform.x,\n            y: event.transform.y\n          }\n        });\n        // TODO: remove this? Shouldn't be mutating state keys directly.\n        this.state.d3.scale = event.transform.k;\n        this.state.d3.translate = {\n          x: event.transform.x,\n          y: event.transform.y\n        };\n      }\n    }));\n  }\n  /**\n   * Assigns internal properties that are required for tree\n   * manipulation to each node in the `data` set and returns a new `data` array.\n   *\n   * @static\n   */\n  static assignInternalProperties(data) {\n    let currentDepth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    // Wrap the root node into an array for recursive transformations if it wasn't in one already.\n    const d = Array.isArray(data) ? data : [data];\n    return d.map(n => {\n      const nodeDatum = n;\n      nodeDatum.__rd3t = {\n        id: null,\n        depth: null,\n        collapsed: false\n      };\n      nodeDatum.__rd3t.id = uuidv4();\n      // D3@v5 compat: manually assign `depth` to node.data so we don't have\n      // to hold full node+link sets in state.\n      // TODO: avoid this extra step by checking D3's node.depth directly.\n      nodeDatum.__rd3t.depth = currentDepth;\n      // If there are children, recursively assign properties to them too.\n      if (nodeDatum.children && nodeDatum.children.length > 0) {\n        nodeDatum.children = Tree.assignInternalProperties(nodeDatum.children, currentDepth + 1);\n      }\n      return nodeDatum;\n    });\n  }\n  /**\n   * Recursively walks the nested `nodeSet` until a node matching `nodeId` is found.\n   */\n  findNodesById(nodeId, nodeSet, hits) {\n    if (hits.length > 0) {\n      return hits;\n    }\n    hits = hits.concat(nodeSet.filter(node => node.__rd3t.id === nodeId));\n    nodeSet.forEach(node => {\n      if (node.children && node.children.length > 0) {\n        hits = this.findNodesById(nodeId, node.children, hits);\n      }\n    });\n    return hits;\n  }\n  /**\n   * Recursively walks the nested `nodeSet` until all nodes at `depth` have been found.\n   *\n   * @param {number} depth Target depth for which nodes should be returned\n   * @param {array} nodeSet Array of nested `node` objects\n   * @param {array} accumulator Accumulator for matches, passed between recursive calls\n   */\n  findNodesAtDepth(depth, nodeSet, accumulator) {\n    accumulator = accumulator.concat(nodeSet.filter(node => node.__rd3t.depth === depth));\n    nodeSet.forEach(node => {\n      if (node.children && node.children.length > 0) {\n        accumulator = this.findNodesAtDepth(depth, node.children, accumulator);\n      }\n    });\n    return accumulator;\n  }\n  /**\n   * Recursively sets the internal `collapsed` property of\n   * the passed `TreeNodeDatum` and its children to `true`.\n   *\n   * @static\n   */\n  static collapseNode(nodeDatum) {\n    nodeDatum.__rd3t.collapsed = true;\n    if (nodeDatum.children && nodeDatum.children.length > 0) {\n      nodeDatum.children.forEach(child => {\n        Tree.collapseNode(child);\n      });\n    }\n  }\n  /**\n   * Sets the internal `collapsed` property of\n   * the passed `TreeNodeDatum` object to `false`.\n   *\n   * @static\n   */\n  static expandNode(nodeDatum) {\n    nodeDatum.__rd3t.collapsed = false;\n  }\n  /**\n   * Collapses all nodes in `nodeSet` that are neighbors (same depth) of `targetNode`.\n   */\n  collapseNeighborNodes(targetNode, nodeSet) {\n    const neighbors = this.findNodesAtDepth(targetNode.__rd3t.depth, nodeSet, []).filter(node => node.__rd3t.id !== targetNode.__rd3t.id);\n    neighbors.forEach(neighbor => Tree.collapseNode(neighbor));\n  }\n  /**\n   * Generates tree elements (`nodes` and `links`) by\n   * grabbing the rootNode from `this.state.data[0]`.\n   * Restricts tree depth to `props.initialDepth` if defined and if this is\n   * the initial render of the tree.\n   */\n  generateTree() {\n    const {\n      initialDepth,\n      depthFactor,\n      separation,\n      nodeSize,\n      orientation\n    } = this.props;\n    const {\n      isInitialRenderForDataset\n    } = this.state;\n    const tree = d3tree().nodeSize(orientation === 'horizontal' ? [nodeSize.y, nodeSize.x] : [nodeSize.x, nodeSize.y]).separation((a, b) => a.parent.data.__rd3t.id === b.parent.data.__rd3t.id ? separation.siblings : separation.nonSiblings);\n    const rootNode = tree(hierarchy(this.state.data[0], d => d.__rd3t.collapsed ? null : d.children));\n    let nodes = rootNode.descendants();\n    const links = rootNode.links();\n    // Configure nodes' `collapsed` property on first render if `initialDepth` is defined.\n    if (initialDepth !== undefined && isInitialRenderForDataset) {\n      this.setInitialTreeDepth(nodes, initialDepth);\n    }\n    if (depthFactor) {\n      nodes.forEach(node => {\n        node.y = node.depth * depthFactor;\n      });\n    }\n    return {\n      nodes,\n      links\n    };\n  }\n  /**\n   * Set initial zoom and position.\n   * Also limit zoom level according to `scaleExtent` on initial display. This is necessary,\n   * because the first time we are setting it as an SVG property, instead of going\n   * through D3's scaling mechanism, which would have picked up both properties.\n   *\n   * @static\n   */\n  static calculateD3Geometry(nextProps) {\n    let scale;\n    if (nextProps.zoom > nextProps.scaleExtent.max) {\n      scale = nextProps.scaleExtent.max;\n    } else if (nextProps.zoom < nextProps.scaleExtent.min) {\n      scale = nextProps.scaleExtent.min;\n    } else {\n      scale = nextProps.zoom;\n    }\n    return {\n      translate: nextProps.translate,\n      scale\n    };\n  }\n  render() {\n    const {\n      nodes,\n      links\n    } = this.generateTree();\n    const {\n      renderCustomNodeElement,\n      orientation,\n      pathFunc,\n      transitionDuration,\n      nodeSize,\n      depthFactor,\n      initialDepth,\n      separation,\n      enableLegacyTransitions,\n      svgClassName,\n      pathClassFunc\n    } = this.props;\n    const {\n      translate,\n      scale\n    } = this.state.d3;\n    const subscriptions = Object.assign(Object.assign(Object.assign({}, nodeSize), separation), {\n      depthFactor,\n      initialDepth\n    });\n    return React.createElement(\"div\", {\n      className: \"rd3t-tree-container rd3t-grabbable\"\n    }, React.createElement(\"style\", null, globalCss), React.createElement(\"svg\", {\n      className: `rd3t-svg ${this.svgInstanceRef} ${svgClassName}`,\n      width: \"100%\",\n      height: \"100%\"\n    }, React.createElement(TransitionGroupWrapper, {\n      enableLegacyTransitions: enableLegacyTransitions,\n      component: \"g\",\n      className: `rd3t-g ${this.gInstanceRef}`,\n      transform: `translate(${translate.x},${translate.y}) scale(${scale})`\n    }, links.map((linkData, i) => {\n      return React.createElement(Link, {\n        key: 'link-' + i,\n        orientation: orientation,\n        pathFunc: pathFunc,\n        pathClassFunc: pathClassFunc,\n        linkData: linkData,\n        onClick: this.handleOnLinkClickCb,\n        onMouseOver: this.handleOnLinkMouseOverCb,\n        onMouseOut: this.handleOnLinkMouseOutCb,\n        enableLegacyTransitions: enableLegacyTransitions,\n        transitionDuration: transitionDuration\n      });\n    }), nodes.map((hierarchyPointNode, i) => {\n      const {\n        data,\n        x,\n        y,\n        parent\n      } = hierarchyPointNode;\n      return React.createElement(Node, {\n        key: 'node-' + i,\n        data: data,\n        position: {\n          x,\n          y\n        },\n        hierarchyPointNode: hierarchyPointNode,\n        parent: parent,\n        nodeClassName: this.getNodeClassName(parent, data),\n        renderCustomNodeElement: renderCustomNodeElement,\n        nodeSize: nodeSize,\n        orientation: orientation,\n        enableLegacyTransitions: enableLegacyTransitions,\n        transitionDuration: transitionDuration,\n        onNodeToggle: this.handleNodeToggle,\n        onNodeClick: this.handleOnNodeClickCb,\n        onNodeMouseOver: this.handleOnNodeMouseOverCb,\n        onNodeMouseOut: this.handleOnNodeMouseOutCb,\n        subscriptions: subscriptions,\n        centerNode: this.centerNode\n      });\n    }))));\n  }\n}\nTree.defaultProps = {\n  onNodeClick: undefined,\n  onNodeMouseOver: undefined,\n  onNodeMouseOut: undefined,\n  onLinkClick: undefined,\n  onLinkMouseOver: undefined,\n  onLinkMouseOut: undefined,\n  onUpdate: undefined,\n  orientation: 'horizontal',\n  translate: {\n    x: 0,\n    y: 0\n  },\n  pathFunc: 'diagonal',\n  pathClassFunc: undefined,\n  transitionDuration: 500,\n  depthFactor: undefined,\n  collapsible: true,\n  initialDepth: undefined,\n  zoomable: true,\n  draggable: true,\n  zoom: 1,\n  scaleExtent: {\n    min: 0.1,\n    max: 1\n  },\n  nodeSize: {\n    x: 140,\n    y: 140\n  },\n  separation: {\n    siblings: 1,\n    nonSiblings: 2\n  },\n  shouldCollapseNeighborNodes: false,\n  svgClassName: '',\n  rootNodeClassName: '',\n  branchNodeClassName: '',\n  leafNodeClassName: '',\n  renderCustomNodeElement: undefined,\n  enableLegacyTransitions: false,\n  hasInteractiveNodes: false,\n  dimensions: undefined,\n  centeringTransitionDuration: 800\n};\nexport default Tree;","map":{"version":3,"names":["React","tree","d3tree","hierarchy","select","zoom","d3zoom","zoomIdentity","dequal","deepEqual","clone","v4","uuidv4","TransitionGroupWrapper","Node","Link","globalCss","Tree","Component","constructor","arguments","state","dataRef","props","data","assignInternalProperties","d3","calculateD3Geometry","isTransitioning","isInitialRenderForDataset","internalState","targetNode","svgInstanceRef","gInstanceRef","handleNodeToggle","nodeId","matches","findNodesById","targetNodeDatum","collapsible","__rd3t","collapsed","expandNode","shouldCollapseNeighborNodes","collapseNeighborNodes","collapseNode","enableLegacyTransitions","setState","setTimeout","transitionDuration","handleOnNodeClickCb","hierarchyPointNode","evt","onNodeClick","persist","handleOnLinkClickCb","linkSource","linkTarget","onLinkClick","handleOnNodeMouseOverCb","onNodeMouseOver","handleOnLinkMouseOverCb","onLinkMouseOver","handleOnNodeMouseOutCb","onNodeMouseOut","handleOnLinkMouseOutCb","onLinkMouseOut","centerNode","dimensions","orientation","centeringTransitionDuration","g","svg","scale","x","y","height","width","transition","duration","attr","call","transform","translate","getNodeClassName","parent","nodeDatum","rootNodeClassName","branchNodeClassName","leafNodeClassName","hasParent","undefined","children","getDerivedStateFromProps","nextProps","prevState","derivedState","componentDidMount","bindZoomListener","componentDidUpdate","prevProps","scaleExtent","zoomable","draggable","onUpdate","node","setInitialTreeDepth","nodeSet","initialDepth","forEach","n","depth","hasInteractiveNodes","min","max","filter","event","target","classList","contains","shiftKey","on","sourceEvent","type","k","currentDepth","length","d","Array","isArray","map","id","hits","concat","findNodesAtDepth","accumulator","child","neighbors","neighbor","generateTree","depthFactor","separation","nodeSize","a","b","siblings","nonSiblings","rootNode","nodes","descendants","links","render","renderCustomNodeElement","pathFunc","svgClassName","pathClassFunc","subscriptions","Object","assign","createElement","className","component","linkData","i","key","onClick","onMouseOver","onMouseOut","position","nodeClassName","onNodeToggle","defaultProps"],"sources":["/home/ubuntu/repo/architec_of_computer_1/hanoi-react/node_modules/react-d3-tree/lib/esm/Tree/index.js"],"sourcesContent":["import React from 'react';\nimport { tree as d3tree, hierarchy } from 'd3-hierarchy';\nimport { select } from 'd3-selection';\nimport { zoom as d3zoom, zoomIdentity } from 'd3-zoom';\nimport { dequal as deepEqual } from 'dequal/lite';\nimport clone from 'clone';\nimport { v4 as uuidv4 } from 'uuid';\nimport TransitionGroupWrapper from './TransitionGroupWrapper.js';\nimport Node from '../Node/index.js';\nimport Link from '../Link/index.js';\nimport globalCss from '../globalCss.js';\nclass Tree extends React.Component {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            dataRef: this.props.data,\n            data: Tree.assignInternalProperties(clone(this.props.data)),\n            d3: Tree.calculateD3Geometry(this.props),\n            isTransitioning: false,\n            isInitialRenderForDataset: true,\n        };\n        this.internalState = {\n            targetNode: null,\n            isTransitioning: false,\n        };\n        this.svgInstanceRef = `rd3t-svg-${uuidv4()}`;\n        this.gInstanceRef = `rd3t-g-${uuidv4()}`;\n        /**\n         * Finds the node matching `nodeId` and\n         * expands/collapses it, depending on the current state of\n         * its internal `collapsed` property.\n         * `setState` callback receives targetNode and handles\n         * `props.onClick` if defined.\n         */\n        this.handleNodeToggle = (nodeId) => {\n            const data = clone(this.state.data);\n            const matches = this.findNodesById(nodeId, data, []);\n            const targetNodeDatum = matches[0];\n            if (this.props.collapsible && !this.state.isTransitioning) {\n                if (targetNodeDatum.__rd3t.collapsed) {\n                    Tree.expandNode(targetNodeDatum);\n                    this.props.shouldCollapseNeighborNodes && this.collapseNeighborNodes(targetNodeDatum, data);\n                }\n                else {\n                    Tree.collapseNode(targetNodeDatum);\n                }\n                if (this.props.enableLegacyTransitions) {\n                    // Lock node toggling while transition takes place.\n                    this.setState({ data, isTransitioning: true });\n                    // Await transitionDuration + 10 ms before unlocking node toggling again.\n                    setTimeout(() => this.setState({ isTransitioning: false }), this.props.transitionDuration + 10);\n                }\n                else {\n                    this.setState({ data });\n                }\n                this.internalState.targetNode = targetNodeDatum;\n            }\n        };\n        /**\n         * Handles the user-defined `onNodeClick` function.\n         */\n        this.handleOnNodeClickCb = (hierarchyPointNode, evt) => {\n            const { onNodeClick } = this.props;\n            if (onNodeClick && typeof onNodeClick === 'function') {\n                // Persist the SyntheticEvent for downstream handling by users.\n                evt.persist();\n                onNodeClick(clone(hierarchyPointNode), evt);\n            }\n        };\n        /**\n         * Handles the user-defined `onLinkClick` function.\n         */\n        this.handleOnLinkClickCb = (linkSource, linkTarget, evt) => {\n            const { onLinkClick } = this.props;\n            if (onLinkClick && typeof onLinkClick === 'function') {\n                // Persist the SyntheticEvent for downstream handling by users.\n                evt.persist();\n                onLinkClick(clone(linkSource), clone(linkTarget), evt);\n            }\n        };\n        /**\n         * Handles the user-defined `onNodeMouseOver` function.\n         */\n        this.handleOnNodeMouseOverCb = (hierarchyPointNode, evt) => {\n            const { onNodeMouseOver } = this.props;\n            if (onNodeMouseOver && typeof onNodeMouseOver === 'function') {\n                // Persist the SyntheticEvent for downstream handling by users.\n                evt.persist();\n                onNodeMouseOver(clone(hierarchyPointNode), evt);\n            }\n        };\n        /**\n         * Handles the user-defined `onLinkMouseOver` function.\n         */\n        this.handleOnLinkMouseOverCb = (linkSource, linkTarget, evt) => {\n            const { onLinkMouseOver } = this.props;\n            if (onLinkMouseOver && typeof onLinkMouseOver === 'function') {\n                // Persist the SyntheticEvent for downstream handling by users.\n                evt.persist();\n                onLinkMouseOver(clone(linkSource), clone(linkTarget), evt);\n            }\n        };\n        /**\n         * Handles the user-defined `onNodeMouseOut` function.\n         */\n        this.handleOnNodeMouseOutCb = (hierarchyPointNode, evt) => {\n            const { onNodeMouseOut } = this.props;\n            if (onNodeMouseOut && typeof onNodeMouseOut === 'function') {\n                // Persist the SyntheticEvent for downstream handling by users.\n                evt.persist();\n                onNodeMouseOut(clone(hierarchyPointNode), evt);\n            }\n        };\n        /**\n         * Handles the user-defined `onLinkMouseOut` function.\n         */\n        this.handleOnLinkMouseOutCb = (linkSource, linkTarget, evt) => {\n            const { onLinkMouseOut } = this.props;\n            if (onLinkMouseOut && typeof onLinkMouseOut === 'function') {\n                // Persist the SyntheticEvent for downstream handling by users.\n                evt.persist();\n                onLinkMouseOut(clone(linkSource), clone(linkTarget), evt);\n            }\n        };\n        /**\n         * Takes a hierarchy point node and centers the node on the screen\n         * if the dimensions parameter is passed to `Tree`.\n         *\n         * This code is adapted from Rob Schmuecker's centerNode method.\n         * Link: http://bl.ocks.org/robschmuecker/7880033\n         */\n        this.centerNode = (hierarchyPointNode) => {\n            const { dimensions, orientation, zoom, centeringTransitionDuration } = this.props;\n            if (dimensions) {\n                const g = select(`.${this.gInstanceRef}`);\n                const svg = select(`.${this.svgInstanceRef}`);\n                const scale = this.state.d3.scale;\n                let x;\n                let y;\n                // if the orientation is horizontal, calculate the variables inverted (x->y, y->x)\n                if (orientation === 'horizontal') {\n                    y = -hierarchyPointNode.x * scale + dimensions.height / 2;\n                    x = -hierarchyPointNode.y * scale + dimensions.width / 2;\n                }\n                else {\n                    // else, calculate the variables normally (x->x, y->y)\n                    x = -hierarchyPointNode.x * scale + dimensions.width / 2;\n                    y = -hierarchyPointNode.y * scale + dimensions.height / 2;\n                }\n                //@ts-ignore\n                g.transition()\n                    .duration(centeringTransitionDuration)\n                    .attr('transform', 'translate(' + x + ',' + y + ')scale(' + scale + ')');\n                // Sets the viewport to the new center so that it does not jump back to original\n                // coordinates when dragged/zoomed\n                //@ts-ignore\n                svg.call(d3zoom().transform, zoomIdentity.translate(x, y).scale(zoom));\n            }\n        };\n        /**\n         * Determines which additional `className` prop should be passed to the node & returns it.\n         */\n        this.getNodeClassName = (parent, nodeDatum) => {\n            const { rootNodeClassName, branchNodeClassName, leafNodeClassName } = this.props;\n            const hasParent = parent !== null && parent !== undefined;\n            if (hasParent) {\n                return nodeDatum.children ? branchNodeClassName : leafNodeClassName;\n            }\n            else {\n                return rootNodeClassName;\n            }\n        };\n    }\n    static getDerivedStateFromProps(nextProps, prevState) {\n        let derivedState = null;\n        // Clone new data & assign internal properties if `data` object reference changed.\n        if (nextProps.data !== prevState.dataRef) {\n            derivedState = {\n                dataRef: nextProps.data,\n                data: Tree.assignInternalProperties(clone(nextProps.data)),\n                isInitialRenderForDataset: true,\n            };\n        }\n        const d3 = Tree.calculateD3Geometry(nextProps);\n        if (!deepEqual(d3, prevState.d3)) {\n            derivedState = derivedState || {};\n            derivedState.d3 = d3;\n        }\n        return derivedState;\n    }\n    componentDidMount() {\n        this.bindZoomListener(this.props);\n        this.setState({ isInitialRenderForDataset: false });\n    }\n    componentDidUpdate(prevProps) {\n        if (this.props.data !== prevProps.data) {\n            // If last `render` was due to change in dataset -> mark the initial render as done.\n            this.setState({ isInitialRenderForDataset: false });\n        }\n        if (!deepEqual(this.props.translate, prevProps.translate) ||\n            !deepEqual(this.props.scaleExtent, prevProps.scaleExtent) ||\n            this.props.zoomable !== prevProps.zoomable ||\n            this.props.draggable !== prevProps.draggable ||\n            this.props.zoom !== prevProps.zoom ||\n            this.props.enableLegacyTransitions !== prevProps.enableLegacyTransitions) {\n            // If zoom-specific props change -> rebind listener with new values.\n            // Or: rebind zoom listeners to new DOM nodes in case legacy transitions were enabled/disabled.\n            this.bindZoomListener(this.props);\n        }\n        if (typeof this.props.onUpdate === 'function') {\n            this.props.onUpdate({\n                node: this.internalState.targetNode ? clone(this.internalState.targetNode) : null,\n                zoom: this.state.d3.scale,\n                translate: this.state.d3.translate,\n            });\n        }\n        // Reset the last target node after we've flushed it to `onUpdate`.\n        this.internalState.targetNode = null;\n    }\n    /**\n     * Collapses all tree nodes with a `depth` larger than `initialDepth`.\n     *\n     * @param {array} nodeSet Array of nodes generated by `generateTree`\n     * @param {number} initialDepth Maximum initial depth the tree should render\n     */\n    setInitialTreeDepth(nodeSet, initialDepth) {\n        nodeSet.forEach(n => {\n            n.data.__rd3t.collapsed = n.depth >= initialDepth;\n        });\n    }\n    /**\n     * bindZoomListener - If `props.zoomable`, binds a listener for\n     * \"zoom\" events to the SVG and sets scaleExtent to min/max\n     * specified in `props.scaleExtent`.\n     */\n    bindZoomListener(props) {\n        const { zoomable, scaleExtent, translate, zoom, onUpdate, hasInteractiveNodes } = props;\n        const svg = select(`.${this.svgInstanceRef}`);\n        const g = select(`.${this.gInstanceRef}`);\n        // Sets initial offset, so that first pan and zoom does not jump back to default [0,0] coords.\n        // @ts-ignore\n        svg.call(d3zoom().transform, zoomIdentity.translate(translate.x, translate.y).scale(zoom));\n        svg.call(d3zoom()\n            .scaleExtent(zoomable ? [scaleExtent.min, scaleExtent.max] : [zoom, zoom])\n            // TODO: break this out into a separate zoom handler fn, rather than inlining it.\n            .filter((event) => {\n            if (hasInteractiveNodes) {\n                return (event.target.classList.contains(this.svgInstanceRef) ||\n                    event.target.classList.contains(this.gInstanceRef) ||\n                    event.shiftKey);\n            }\n            return true;\n        })\n            .on('zoom', (event) => {\n            if (!this.props.draggable && (event.sourceEvent.type === 'mousemove')) {\n                return;\n            }\n            g.attr('transform', event.transform);\n            if (typeof onUpdate === 'function') {\n                // This callback is magically called not only on \"zoom\", but on \"drag\", as well,\n                // even though event.type == \"zoom\".\n                // Taking advantage of this and not writing a \"drag\" handler.\n                onUpdate({\n                    node: null,\n                    zoom: event.transform.k,\n                    translate: { x: event.transform.x, y: event.transform.y },\n                });\n                // TODO: remove this? Shouldn't be mutating state keys directly.\n                this.state.d3.scale = event.transform.k;\n                this.state.d3.translate = {\n                    x: event.transform.x,\n                    y: event.transform.y,\n                };\n            }\n        }));\n    }\n    /**\n     * Assigns internal properties that are required for tree\n     * manipulation to each node in the `data` set and returns a new `data` array.\n     *\n     * @static\n     */\n    static assignInternalProperties(data, currentDepth = 0) {\n        // Wrap the root node into an array for recursive transformations if it wasn't in one already.\n        const d = Array.isArray(data) ? data : [data];\n        return d.map(n => {\n            const nodeDatum = n;\n            nodeDatum.__rd3t = { id: null, depth: null, collapsed: false };\n            nodeDatum.__rd3t.id = uuidv4();\n            // D3@v5 compat: manually assign `depth` to node.data so we don't have\n            // to hold full node+link sets in state.\n            // TODO: avoid this extra step by checking D3's node.depth directly.\n            nodeDatum.__rd3t.depth = currentDepth;\n            // If there are children, recursively assign properties to them too.\n            if (nodeDatum.children && nodeDatum.children.length > 0) {\n                nodeDatum.children = Tree.assignInternalProperties(nodeDatum.children, currentDepth + 1);\n            }\n            return nodeDatum;\n        });\n    }\n    /**\n     * Recursively walks the nested `nodeSet` until a node matching `nodeId` is found.\n     */\n    findNodesById(nodeId, nodeSet, hits) {\n        if (hits.length > 0) {\n            return hits;\n        }\n        hits = hits.concat(nodeSet.filter(node => node.__rd3t.id === nodeId));\n        nodeSet.forEach(node => {\n            if (node.children && node.children.length > 0) {\n                hits = this.findNodesById(nodeId, node.children, hits);\n            }\n        });\n        return hits;\n    }\n    /**\n     * Recursively walks the nested `nodeSet` until all nodes at `depth` have been found.\n     *\n     * @param {number} depth Target depth for which nodes should be returned\n     * @param {array} nodeSet Array of nested `node` objects\n     * @param {array} accumulator Accumulator for matches, passed between recursive calls\n     */\n    findNodesAtDepth(depth, nodeSet, accumulator) {\n        accumulator = accumulator.concat(nodeSet.filter(node => node.__rd3t.depth === depth));\n        nodeSet.forEach(node => {\n            if (node.children && node.children.length > 0) {\n                accumulator = this.findNodesAtDepth(depth, node.children, accumulator);\n            }\n        });\n        return accumulator;\n    }\n    /**\n     * Recursively sets the internal `collapsed` property of\n     * the passed `TreeNodeDatum` and its children to `true`.\n     *\n     * @static\n     */\n    static collapseNode(nodeDatum) {\n        nodeDatum.__rd3t.collapsed = true;\n        if (nodeDatum.children && nodeDatum.children.length > 0) {\n            nodeDatum.children.forEach(child => {\n                Tree.collapseNode(child);\n            });\n        }\n    }\n    /**\n     * Sets the internal `collapsed` property of\n     * the passed `TreeNodeDatum` object to `false`.\n     *\n     * @static\n     */\n    static expandNode(nodeDatum) {\n        nodeDatum.__rd3t.collapsed = false;\n    }\n    /**\n     * Collapses all nodes in `nodeSet` that are neighbors (same depth) of `targetNode`.\n     */\n    collapseNeighborNodes(targetNode, nodeSet) {\n        const neighbors = this.findNodesAtDepth(targetNode.__rd3t.depth, nodeSet, []).filter(node => node.__rd3t.id !== targetNode.__rd3t.id);\n        neighbors.forEach(neighbor => Tree.collapseNode(neighbor));\n    }\n    /**\n     * Generates tree elements (`nodes` and `links`) by\n     * grabbing the rootNode from `this.state.data[0]`.\n     * Restricts tree depth to `props.initialDepth` if defined and if this is\n     * the initial render of the tree.\n     */\n    generateTree() {\n        const { initialDepth, depthFactor, separation, nodeSize, orientation } = this.props;\n        const { isInitialRenderForDataset } = this.state;\n        const tree = d3tree()\n            .nodeSize(orientation === 'horizontal' ? [nodeSize.y, nodeSize.x] : [nodeSize.x, nodeSize.y])\n            .separation((a, b) => a.parent.data.__rd3t.id === b.parent.data.__rd3t.id\n            ? separation.siblings\n            : separation.nonSiblings);\n        const rootNode = tree(hierarchy(this.state.data[0], d => (d.__rd3t.collapsed ? null : d.children)));\n        let nodes = rootNode.descendants();\n        const links = rootNode.links();\n        // Configure nodes' `collapsed` property on first render if `initialDepth` is defined.\n        if (initialDepth !== undefined && isInitialRenderForDataset) {\n            this.setInitialTreeDepth(nodes, initialDepth);\n        }\n        if (depthFactor) {\n            nodes.forEach(node => {\n                node.y = node.depth * depthFactor;\n            });\n        }\n        return { nodes, links };\n    }\n    /**\n     * Set initial zoom and position.\n     * Also limit zoom level according to `scaleExtent` on initial display. This is necessary,\n     * because the first time we are setting it as an SVG property, instead of going\n     * through D3's scaling mechanism, which would have picked up both properties.\n     *\n     * @static\n     */\n    static calculateD3Geometry(nextProps) {\n        let scale;\n        if (nextProps.zoom > nextProps.scaleExtent.max) {\n            scale = nextProps.scaleExtent.max;\n        }\n        else if (nextProps.zoom < nextProps.scaleExtent.min) {\n            scale = nextProps.scaleExtent.min;\n        }\n        else {\n            scale = nextProps.zoom;\n        }\n        return {\n            translate: nextProps.translate,\n            scale,\n        };\n    }\n    render() {\n        const { nodes, links } = this.generateTree();\n        const { renderCustomNodeElement, orientation, pathFunc, transitionDuration, nodeSize, depthFactor, initialDepth, separation, enableLegacyTransitions, svgClassName, pathClassFunc, } = this.props;\n        const { translate, scale } = this.state.d3;\n        const subscriptions = Object.assign(Object.assign(Object.assign({}, nodeSize), separation), { depthFactor,\n            initialDepth });\n        return (React.createElement(\"div\", { className: \"rd3t-tree-container rd3t-grabbable\" },\n            React.createElement(\"style\", null, globalCss),\n            React.createElement(\"svg\", { className: `rd3t-svg ${this.svgInstanceRef} ${svgClassName}`, width: \"100%\", height: \"100%\" },\n                React.createElement(TransitionGroupWrapper, { enableLegacyTransitions: enableLegacyTransitions, component: \"g\", className: `rd3t-g ${this.gInstanceRef}`, transform: `translate(${translate.x},${translate.y}) scale(${scale})` },\n                    links.map((linkData, i) => {\n                        return (React.createElement(Link, { key: 'link-' + i, orientation: orientation, pathFunc: pathFunc, pathClassFunc: pathClassFunc, linkData: linkData, onClick: this.handleOnLinkClickCb, onMouseOver: this.handleOnLinkMouseOverCb, onMouseOut: this.handleOnLinkMouseOutCb, enableLegacyTransitions: enableLegacyTransitions, transitionDuration: transitionDuration }));\n                    }),\n                    nodes.map((hierarchyPointNode, i) => {\n                        const { data, x, y, parent } = hierarchyPointNode;\n                        return (React.createElement(Node, { key: 'node-' + i, data: data, position: { x, y }, hierarchyPointNode: hierarchyPointNode, parent: parent, nodeClassName: this.getNodeClassName(parent, data), renderCustomNodeElement: renderCustomNodeElement, nodeSize: nodeSize, orientation: orientation, enableLegacyTransitions: enableLegacyTransitions, transitionDuration: transitionDuration, onNodeToggle: this.handleNodeToggle, onNodeClick: this.handleOnNodeClickCb, onNodeMouseOver: this.handleOnNodeMouseOverCb, onNodeMouseOut: this.handleOnNodeMouseOutCb, subscriptions: subscriptions, centerNode: this.centerNode }));\n                    })))));\n    }\n}\nTree.defaultProps = {\n    onNodeClick: undefined,\n    onNodeMouseOver: undefined,\n    onNodeMouseOut: undefined,\n    onLinkClick: undefined,\n    onLinkMouseOver: undefined,\n    onLinkMouseOut: undefined,\n    onUpdate: undefined,\n    orientation: 'horizontal',\n    translate: { x: 0, y: 0 },\n    pathFunc: 'diagonal',\n    pathClassFunc: undefined,\n    transitionDuration: 500,\n    depthFactor: undefined,\n    collapsible: true,\n    initialDepth: undefined,\n    zoomable: true,\n    draggable: true,\n    zoom: 1,\n    scaleExtent: { min: 0.1, max: 1 },\n    nodeSize: { x: 140, y: 140 },\n    separation: { siblings: 1, nonSiblings: 2 },\n    shouldCollapseNeighborNodes: false,\n    svgClassName: '',\n    rootNodeClassName: '',\n    branchNodeClassName: '',\n    leafNodeClassName: '',\n    renderCustomNodeElement: undefined,\n    enableLegacyTransitions: false,\n    hasInteractiveNodes: false,\n    dimensions: undefined,\n    centeringTransitionDuration: 800,\n};\nexport default Tree;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}